Using Guice's modules to add bindings can be cumbersome and tedious. It's also unnecessary for most simple types of binding. Governator can scan your CLASSPATH to do "auto binding". There are two types of auto binding supported:

* AutoBindSingleton
* AutoBind (for injected arguments/fields)

h2. Configuration

Governator will only scan configured packages from the CLASSPATH. Set the packages to use with the @usingBasePackages()@ method of the @LifecycleInjectorBuilder@.

h2. AutoBindSingleton

Classes annotated with @AutoBindSingleton@ will get auto-bound as Eager Singletons. This is useful for stand-alone classes such as cleanup tasks, etc. that aren't referred to in the code. E.g.

```java
@AutoBindSingleton
public class MyClass {
   ...
}
```

Governator will bind this class as:


```java
binder.bind(MyClass.class).asEagerSingleton();
```

h2. Fields and Arguments

Governator has a method for auto binding injected constructor/method argument and injected fields via the @AutoBind@ annotation. As Governator is scanning the CLASSPATH, it looks for injection sites that are annotated with @AutoBind@ (or custom auto bind annotations - see below). The actual binding is done via an @AutoBindProvider@ that you create.

Here's an example usage: imagine a class "PropertyName" that is used throughout your application. PropertyName is a POJO that holds a String - a property name. Everywhere PropertyName is used it might have a different value and there are possibly hundreds of these usages. Without Governator, you'd need to bind each of those usages. With @AutoBind, you can create the bindings much each easier.

```java
public class MyClass {
    @Inject
    public MyClass(@AutoBind("a value") PropertyName p)
}

public class AnotherClass {
    @Inject
    public AnotherClass(@AutoBind("different value") PropertyName p)
}

...
```