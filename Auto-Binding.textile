Using Guice's modules to add bindings can be cumbersome and tedious. It's also unnecessary for most simple types of binding. Governator can scan your CLASSPATH to do "auto binding". There are two types of auto binding supported:

* AutoBindSingleton
* AutoBind (for injected arguments/fields)

h2. Configuration

Governator will only scan configured packages from the CLASSPATH. Set the packages to use with the @usingBasePackages()@ method of the @LifecycleInjectorBuilder@.

h2. AutoBindSingleton

Classes annotated with @AutoBindSingleton@ will get auto-bound as Eager Singletons. This is useful for stand-alone classes such as cleanup tasks, etc. that aren't referred to in the code. E.g.

```java
@AutoBindSingleton
public class MyClass {
   ...
}
```

Governator will bind this class as:


```java
binder.bind(MyClass.class).asEagerSingleton();
```

h2. Fields and Arguments

Governator has a method for auto binding injected constructor/method argument and injected fields via the @AutoBind@ annotation. As Governator is scanning the CLASSPATH, it looks for injection sites that are annotated with @AutoBind@ (or custom auto bind annotations - see below). The actual binding is done via an @AutoBindProvider@ that you create.

Here's an example usage: imagine a class "PropertyName" that is used throughout your application. PropertyName is a POJO that holds a String - a property name. Everywhere PropertyName is used it might have a different value and there are possibly hundreds of these usages. Without Governator, you'd need to bind each of those usages. With @AutoBind, you can create the bindings much each easier.

```java
public class MyClass {
    @Inject
    public MyClass(@AutoBind("a value") PropertyName p)
}

public class AnotherClass {
    @Inject
    public AnotherClass(@AutoBind("different value") PropertyName p)
}

...
```

To do the actual binding, create an instance of AutoBindProvider. For the above example, it would be something like this:

```java
public class MyAutoBindProvider implements AutoBindProvider<AutoBind> {
    public void     configure(Binder binder, AutoBind annotation) {
        PropertyName p = new PropertyName(annotation.getValue());
        binder.bind(PropertyName.class).annotatedWith(annotation).toInstance(p);
    }
}
```

You must bind your AutoBindProvider in Governator's [[Bootstrapping]] phase:

```java
LifecycleInjectorBuilder    builder = ...
builder.withBootstrapModule(new BootstrapModule(){
    public void configure(BootstrapBinder binder) {
        binder.bind(new TypeLiteral<AutoBindProvider<AutoBind>>(){}).toInstance(MyAutoBindProvider);
    }
});
```

h3. Custom AutoBind Annotations

AutoBind supports custom annotations as well. You can use custom AutoBind annotations to capture additional parameters and/or to differentiate different auto bind scenarios. A custom AutoBind annotation looks like this:

```java
@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE, ElementType.PARAMETER})
@BindingAnnotation
@AutoBind
public @interface CustomAutoBind
{
    String      name();

    long        id();
}
```

Notice that your custom Auto Bind annotation must itself be annotated with @AutoBind and @BindingAnnotation. You then must bind an AutoBindProvider for the custom annotation in the bootstrap binder:

```java
binder.bind(new TypeLiteral<AutoBindProvider<CustomAutoBind>>(){}).toInstance(MyCustomAutoBindProvider);
```