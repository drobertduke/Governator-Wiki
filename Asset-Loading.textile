h2. Introduction

Sometimes a class will have a dependency that can't be coded as a direct dependency - i.e. there is no object that represents the dependency. One could write a scaffold class to denote the dependency but that is clumsy as the scaffold instance would never get used.

E.g. clumsy method of asset loading:

```java
public class MyAssetLoader
{
   // ... code to load the asset goes here
}

public class Foo
{
    @Inject
    public Foo(MyAssetLoader loader){}
}
```

The MyAssetLoader injected into Foo exists only so that Guice will instantiate MyAssetLoader and, thus, cause the loading code to execute. Foo will never execute any methods of MyAssetLoader.

Governator introduces a method to declare dependencies of this type. The declaration is done via the @RequiredAsset annotation. In the above example, instead of creating the awkward MyAssetLoader class and injecting it into Foo, you would annotate Foo as requiring an asset:

```java
@RequiredAsset("My Asset")
public class Foo
{
    // ...
}
```

Governator will load the required asset by using a bound AssetLoader instance. Additionally, you can bind optional parameters for asset loaders to customize loading behavior.

h2. Required Asset Examples

Some examples of required assets are:

* Property files: .property files that need to be loaded for an object
* Certificates: SSL certs, etc. that need to be loaded and initialized for an object
* Clean up tasks: background tasks that need to be started for a set of objects
* Etc.

h2. RequiredAssets and AssetLoaders

RequiredAssets are processed via instances of <code>AssetLoader</code>:

```java
/**
 * Abstraction for loading classes annotated with {@link RequiredAsset}
 */
public interface AssetLoader
{
    /**
     * Called to load the named asset
     *
     * @param name name of the asset
     */
    public void     loadAsset(String name) throws Exception;

    /**
     * Called to unload the named asset
     *
     * @param name name of the asset
     */
    public void     unloadAsset(String name) throws Exception;
}
```

Which asset loader is used depends on your binding choices during [[Bootstrapping]]. You can bind a default asset loader by using <code>BootstrapBinder.bindDefaultAssetLoader()</code>. You can also specify an asset loader as an optional argument to the @RequiredAsset annotation:

```java
@RequiredAsset(value = "my name", loader = MyAssetLoader.class)
```

Lastly, you can bind an AssetLoader for a specific asset name via <code>BootstrapBinder.bindAssetLoader(String assetName)</code>.

Governator chooses the asset loader in the following way:

# If an asset loader is bound for the specific asset name, it is used ignoring any other binding.
# If the @RequiredAsset annotation has a loader specified, it is used
# Lastly, the default asset loader is used

Here's an example AssetLoader that reads a property file and adds all the values to the System properties:

```java
public class MyAssetLoader implements AssetLoader
{
    public void     loadAsset(String name) throws Exception
    {
        Properties    p = loadPropertiesFile(name); // call method to load properties file 
        System.setProperties(p);
    }
}
```

Given this, classes can specify that they required properties files to be loaded. E.g.

```java
@RequiredAsset(value = "myProperties.txt", loader = MyAssetLoader.class)
public class MyClass
    ...
```

When Guice injects MyClass, Governator will call MyAssetLoader with "myProperties.txt" prior to calling an methods marked with @PostConstruct.

h2. AssetLoader Parameters

You can use standard Guice methods of specifying parameters/options for an AssetLoader. However, Governator has a preferred method that is somewhat simpler. Use <code>BootstrapBinder.bindAssetParameter()</code> to set a parameter for a specific asset name. AssetLoader instances can then examine that parameter by injecting all asset parameters as maps from asset name to parameter.

For example, to support an optional String parameter for an asset loader:

```java
public class MyAssetLoader implements AssetLoader
{
    @Inject(optional = true)
    private Map<String, String> parameters = new HashMap<String, String>();
    ...

    public void     loadAsset(String name) throws Exception
    {
        String optionalValue = parameters.get(name);
        ...
    }
}
```

In the above, "parameters" is marked optional. Guice will only inject if a binding is explicitly made - otherwise the field is left unchanged (i.e. it will be the map in the assignment).

Governator has a method for setting asset loader parameters during [[Bootstrapping]]. Use the BootstrapBinder. In this example:

```java
        Injector        injector = LifecycleInjector.builder()
            .withBootstrapModule
            (
                new BootstrapModule()
                {
                    @Override
                    public void configure(BootstrapBinder binder)
                    {
                        // binds an optional parameter for the asset named "test"
                        binder.bindAssetParameter("test", String.class).toInstance("Whatever");
                    }
                }
            )
            ...
```