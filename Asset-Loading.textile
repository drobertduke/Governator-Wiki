Sometimes a class will have a dependency that can't be coded as a direct dependency - i.e. there is no object that represents the dependency. One could write a scaffold class to denote the dependency but that is clumsy as the scaffold instance would never get used.

E.g. clumsy method of asset loading:

```java
public class MyAssetLoader
{
   // ... code to load the asset goes here
}

public class Foo
{
    @Inject
    public Foo(MyAssetLoader loader){}
}
```

The MyAssetLoader injected into Foo exists only so that Guice will instantiate MyAssetLoader and, thus, cause the loading code to execute. Foo will never execute any methods of MyAssetLoader.

Governator introduces a method to declare dependencies of this type. The declaration is done via the @RequiredAsset annotation. In the above example, instead of creating the awkward MyAssetLoader class and injecting it into Foo, you would annotate Foo as requiring an asset:

```java
@RequiredAsset("My Asset")
public class Foo
{
    // ...
}
```

Governator will load the required asset by using a bound AssetLoader instance. Additionally, you can bind optional parameters for asset loaders to customize loading behavior.