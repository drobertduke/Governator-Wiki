h2. Introduction

Sometimes a class will have a dependency that can't be coded as a direct dependency - i.e. there is no object that represents the dependency. One could write a scaffold class to denote the dependency but that is clumsy as the scaffold instance would never get used.

E.g. clumsy method of asset loading:

```java
public class MyAssetLoader
{
   // ... code to load the asset goes here
}

public class Foo
{
    @Inject
    public Foo(MyAssetLoader loader){}
}
```

The MyAssetLoader injected into Foo exists only so that Guice will instantiate MyAssetLoader and, thus, cause the loading code to execute. Foo will never execute any methods of MyAssetLoader.

Governator introduces a method to declare dependencies of this type. The declaration is done via the @RequiredAsset annotation. In the above example, instead of creating the awkward MyAssetLoader class and injecting it into Foo, you would annotate Foo as requiring an asset:

```java
@RequiredAsset("My Asset")
public class Foo
{
    // ...
}
```

Governator will load the required asset by using a bound AssetLoader instance. Additionally, you can bind optional parameters for asset loaders to customize loading behavior.

h2. Required Asset Examples

Some examples of required assets are:

* Property files: .property files that need to be loaded for an object
* Certificates: SSL certs, etc. that need to be loaded and initialized for an object
* Clean up tasks: background tasks that need to be started for a set of objects
* Etc.

h2. RequiredAssets and AssetLoaders

RequiredAssets are processed via instances of <code>AssetLoader</code>:

```java
/**
 * Abstraction for loading classes annotated with {@link RequiredAsset}
 */
public interface AssetLoader
{
    /**
     * Called to load the named asset
     *
     * @param name name of the asset
     */
    public void     loadAsset(String name) throws Exception;

    /**
     * Called to unload the named asset
     *
     * @param name name of the asset
     */
    public void     unloadAsset(String name) throws Exception;
}
```

Which asset loader is used depends on your binding choices during [[Bootstrapping]]. You can bind a default asset loader by using <code>BootstrapBinder.bindDefaultAssetLoader()</code>. You can also specify an asset loader as an optional argument to the @RequiredAsset annotation:

```java
@RequiredAsset(value = "my name", loader = MyAssetLoader.class)
```

Lastly, you can bind an AssetLoader for a specific asset name via <code>BootstrapBinder.bindAssetLoader(String assetName)</code>.

Governator chooses the asset loader in the following way:

# If an asset loader is bound for the specific asset name, it is used ignoring any other binding.
# If the @RequiredAsset annotation has a loader specified, it is used
# Lastly, the default asset loader is used